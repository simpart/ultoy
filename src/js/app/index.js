!function(n){var e={};function t(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return n[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{configurable:!1,enumerable:!0,get:r})},t.r=function(n){Object.defineProperty(n,"__esModule",{value:!0})},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t.w={},t(t.s="./src/js/init/index.js")}({"./node_modules/babel-loader/lib/index.js??ref--4!./node_modules/mofron/src/core/namesp.js":function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n * @file namespace.js\n * @author simpart\n */\nmodule.exports = {\n    comp: {},\n    layout: {},\n    event: {},\n    effect: {},\n    func: {},\n    theme: null,\n    root: new Array(),\n    debug: false\n};\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/namesp.js?./node_modules/babel-loader/lib??ref--4")},"./node_modules/babel-loader/lib/index.js??ref--4!./src/js/conf/namesp.js":function(module,exports,__webpack_require__){"use strict";eval('\n\n/**\n * @file namesp.js\n * @brief define namespace\n */\nvar mf = __webpack_require__(/*! mofron */ "./node_modules/mofron/index.js");\nmodule.exports = {\n  root: new mf.Component(),\n  conf: {}\n};\n/* end of file */\n\n//# sourceURL=webpack:///./src/js/conf/namesp.js?./node_modules/babel-loader/lib??ref--4')},"./node_modules/expose-loader/index.js?app!./src/js/conf/namesp.js-exposed":function(module,exports,__webpack_require__){eval('module.exports = global["app"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib??ref--4!./namesp.js */ "./node_modules/babel-loader/lib/index.js??ref--4!./src/js/conf/namesp.js");\n\n//# sourceURL=webpack:///./src/js/conf/namesp.js-exposed?./node_modules/expose-loader?app')},"./node_modules/expose-loader/index.js?mofron!./node_modules/mofron/src/core/namesp.js-exposed":function(module,exports,__webpack_require__){eval('module.exports = global["mofron"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib??ref--4!./namesp.js */ "./node_modules/babel-loader/lib/index.js??ref--4!./node_modules/mofron/src/core/namesp.js");\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/namesp.js-exposed?./node_modules/expose-loader?mofron')},"./node_modules/mofron/index.js":function(module,exports,__webpack_require__){"use strict";eval('\n\n__webpack_require__(/*! expose-loader?mofron!./src/core/namesp.js */ "./node_modules/expose-loader/index.js?mofron!./node_modules/mofron/src/core/namesp.js-exposed");\n__webpack_require__(/*! ./src/common/Base.js */ "./node_modules/mofron/src/common/Base.js");\n__webpack_require__(/*! ./src/common/Param.js */ "./node_modules/mofron/src/common/Param.js");\nmofron.func = __webpack_require__(/*! ./src/common/function.js */ "./node_modules/mofron/src/common/function.js");\n\n__webpack_require__(/*! ./src/util/conf/DomConf.js */ "./node_modules/mofron/src/util/conf/DomConf.js");\n__webpack_require__(/*! ./src/util/conf/Attr.js */ "./node_modules/mofron/src/util/conf/Attr.js");\n__webpack_require__(/*! ./src/util/conf/ClassName.js */ "./node_modules/mofron/src/util/conf/ClassName.js");\n__webpack_require__(/*! ./src/util/conf/DomConf.js */ "./node_modules/mofron/src/util/conf/DomConf.js");\n__webpack_require__(/*! ./src/util/conf/Prop.js */ "./node_modules/mofron/src/util/conf/Prop.js");\n__webpack_require__(/*! ./src/util/conf/Style.js */ "./node_modules/mofron/src/util/conf/Style.js");\n__webpack_require__(/*! ./src/util/conf/CompConf.js */ "./node_modules/mofron/src/util/conf/CompConf.js");\n\n__webpack_require__(/*! ./src/util/dom/Dom.js */ "./node_modules/mofron/src/util/dom/Dom.js");\n__webpack_require__(/*! ./src/util/dom/Adom.js */ "./node_modules/mofron/src/util/dom/Adom.js");\n\n__webpack_require__(/*! ./src/util/Color.js */ "./node_modules/mofron/src/util/Color.js");\n__webpack_require__(/*! ./src/util/Font.js */ "./node_modules/mofron/src/util/Font.js");\n__webpack_require__(/*! ./src/util/Theme.js */ "./node_modules/mofron/src/util/Theme.js");\n\n__webpack_require__(/*! ./src/core/Component.js */ "./node_modules/mofron/src/core/Component.js");\n__webpack_require__(/*! ./src/core/Layout.js */ "./node_modules/mofron/src/core/Layout.js");\n__webpack_require__(/*! ./src/core/Event.js */ "./node_modules/mofron/src/core/Event.js");\n__webpack_require__(/*! ./src/core/Effect.js */ "./node_modules/mofron/src/core/Effect.js");\n__webpack_require__(/*! ./src/core/Template.js */ "./node_modules/mofron/src/core/Template.js");\nmodule.exports = mofron;\n\n//# sourceURL=webpack:///./node_modules/mofron/index.js?')},"./node_modules/mofron/src/common/Base.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @file Base.js\n * @author simpart\n */\n\n/**\n * @class Base\n * @brief top of mofron parent class\n */\nmofron.Base = function () {\n    function _class() {\n        _classCallCheck(this, _class);\n\n        try {\n            this.m_name = new Array();\n            this.name('Base');\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n    }\n\n    /**\n     * component name setter / getter\n     *\n     * @param nm : (string) component name\n     * @return (string) component name\n     * @note parameter syntax\n     */\n\n\n    _createClass(_class, [{\n        key: 'name',\n        value: function name(nm) {\n            try {\n                if (undefined === nm) {\n                    if (0 === this.m_name.length) {\n                        return null;\n                    }\n                    return this.m_name[this.m_name.length - 1];\n                }\n                if (!('string' === typeof nm || 'object' === (typeof nm === 'undefined' ? 'undefined' : _typeof(nm)) && undefined !== nm[0])) {\n                    throw new Error('invalid parameter');\n                }\n                if ('object' === (typeof nm === 'undefined' ? 'undefined' : _typeof(nm))) {\n                    for (var idx in nm) {\n                        this.m_name.push(nm[idx]);\n                    }\n                } else {\n                    this.m_name.push(nm);\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'data',\n        value: function data(key, val) {\n            try {\n                if (undefined === val) {\n                    /* getter */\n                    if (undefined === this.m_data) {\n                        return null;\n                    }\n                    return undefined === this.m_data[key] ? null : this.m_data[key];\n                }\n                /* setter */\n                if ('string' !== typeof key) {\n                    throw new Error('invalid parameter');\n                }\n                if (undefined === this.m_data) {\n                    this.m_data = {};\n                }\n                this.m_data[key] = val;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'getNameList',\n        value: function getNameList() {\n            try {\n                return this.m_name;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'getId',\n        value: function getId() {\n            try {\n                if (undefined === this.m_id) {\n                    this.m_id = mofron.func.getId();\n                }\n                return this.m_id;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'param',\n        value: function param(prm) {\n            try {\n                if (undefined === prm) {\n                    /* getter */\n                    return undefined === this.m_param ? null : this.m_param;\n                }\n                /* setter */\n                this.m_param = prm;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'getOption',\n        value: function getOption() {\n            try {\n                return undefined === this.m_opt ? null : this.m_opt;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'addOption',\n        value: function addOption(opt) {\n            try {\n                if ('object' !== (typeof opt === 'undefined' ? 'undefined' : _typeof(opt))) {\n                    throw new Error('invalid parameter');\n                }\n                if (undefined === this.m_opt) {\n                    this.m_opt = {};\n                }\n                for (var oidx in opt) {\n                    this.m_opt[oidx] = opt[oidx];\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'setPrmOpt',\n        value: function setPrmOpt(po, p2, p3, p4, p5) {\n            try {\n                var prm_cnt = 0;\n                for (var pidx in arguments) {\n                    if (undefined !== arguments[pidx]) {\n                        prm_cnt++;\n                    }\n                }\n                if (0 === prm_cnt) {\n                    return;\n                } else if (1 === prm_cnt) {\n                    if ('object' === (typeof po === 'undefined' ? 'undefined' : _typeof(po))) {\n                        if (\"undefined\" === typeof po[0]) {\n                            if (true === mofron.func.isInclude(po, 'Base')) {\n                                /* this is parameter */\n                                this.param(new mofron.Param(po));\n                                return;\n                            }\n\n                            for (var pidx2 in po) {\n                                if ('string' !== typeof pidx2) {\n                                    /* this is paramter */\n                                    this.param(new mofron.Param(po));\n                                    return;\n                                }\n                            }\n                            /* this is option */\n                            this.addOption(po);\n                        } else {\n                            /* this is paramter */\n                            this.param(new mofron.Param(po));\n                        }\n                    } else {\n                        /* this is paramter */\n                        this.param(new mofron.Param(po, p2, p3, p4, p5));\n                    }\n                } else {\n                    this.param(new mofron.Param(po, p2, p3, p4, p5));\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'prmOpt',\n        value: function prmOpt(po, p1, p2, p3, p4) {\n            try {\n                this.setPrmOpt(po, p1, p2, p3, p4);\n                var opt = this.getOption();\n                if (null !== opt) {\n                    this.execOption();\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'delOption',\n        value: function delOption(key) {\n            try {\n                if ('string' !== typeof key) {\n                    throw new Error('invalid parameter');\n                }\n                delete this.m_opt[key];\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'execOption',\n        value: function execOption(opt) {\n            try {\n                if (undefined !== opt) {\n                    this.addOption(opt);\n                } else {\n                    opt = this.getOption();\n                }\n\n                if (null === opt) {\n                    return;\n                }\n\n                for (var opt_idx in opt) {\n                    if ('function' === typeof this[opt_idx]) {\n                        if ('name' === this[opt_idx]) {\n                            throw new Error('invalid option name');\n                        }\n                        if (true === mofron.func.isObject(opt[opt_idx], 'Param')) {\n                            opt[opt_idx].call(this, opt_idx);\n                        } else {\n                            this[opt_idx](opt[opt_idx]);\n                        }\n                    }\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}();\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/common/Base.js?")},"./node_modules/mofron/src/common/Param.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file Param.js\n * @author simpart\n */\n\n/**\n * @class Param\n * @brief option paramter for mofron object\n */\nmofron.Param = function (_mofron$Base) {\n    _inherits(_class, _mofron$Base);\n\n    function _class() {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));\n\n            _this.name('Param');\n\n            _this.m_param = new Array();\n            for (var idx in arguments) {\n                if (undefined === arguments[idx]) {\n                    continue;\n                }\n                _this.m_param.push(arguments[idx]);\n            }\n\n            if (0 === _this.m_param.length) {\n                throw new Error('too few parameter');\n            } else if (5 <= _this.m_param.length) {\n                throw new Error('too many parameters');\n            }\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    _createClass(_class, [{\n        key: 'getParam',\n        value: function getParam() {\n            try {\n                return this.m_param;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'call',\n        value: function call(obj, func) {\n            try {\n                if (null === obj || 'object' !== (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) {\n                    throw new Error('invalid paramter');\n                }\n                if ('string' !== typeof func) {\n                    throw new Error('invalid parameter');\n                }\n                var prm = this.getParam();\n                if (1 === prm.length) {\n                    console.warn('you shuld call ' + func + '() without mofron.Param object');\n                    obj[func](prm[0]);\n                } else if (2 === prm.length) {\n                    obj[func](prm[0], prm[1]);\n                } else if (3 === prm.length) {\n                    obj[func](prm[0], prm[1], prm[2]);\n                } else if (4 === prm.length) {\n                    obj[func](prm[0], prm[1], prm[2], prm[3]);\n                } else {\n                    obj[func](prm[0], prm[1], prm[2], prm[3], prm[4]);\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.Base);\n\n//# sourceURL=webpack:///./node_modules/mofron/src/common/Param.js?")},"./node_modules/mofron/src/common/function.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * @file function.js\n * @brief util functions\n * @author simpart\n */\n\nmodule.exports = {\n    /**\n     * get unique id\n     *\n     * @param tgt : (object) target mofron object\n     * @return (string) unique id\n     */\n    getId: function getId(tgt) {\n        try {\n            var _tgt = tgt === undefined ? null : tgt;\n            var ipf = \"aid\";\n            if (null !== _tgt) {\n                ipf = _tgt.name();\n            }\n            var ret_id = ipf + '-' + new Date().getTime() + '-';\n            var loop = 0;\n            var val = 0;\n            for (loop = 0; loop < 8; loop++) {\n                val = Math.random() * 16 | 0;\n                ret_id += (loop == 12 ? 4 : loop == 16 ? val & 3 | 8 : val).toString(16);\n            }\n            return ret_id;\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n    },\n\n    getCamel: function getCamel(sty) {\n        try {\n            if ('string' !== typeof sty) {\n                throw new Error('invalid parameter');\n            }\n\n            if (sty.length - 1 === sty.lastIndexOf('-')) {\n                throw new Error('invalid parameter');\n            }\n\n            var skip = false;\n            if (0 === sty.indexOf('-')) {\n                skip = true;\n            }\n\n            var ret_val = sty;\n            var ret_buf = null;\n            var up_str = null;\n            var idx = null;\n            while (true) {\n                idx = ret_val.indexOf('-');\n                if (-1 === idx) {\n                    break;\n                }\n                up_str = ret_val.charAt(idx + 1).toUpperCase();\n                ret_buf = ret_val.substr(0, idx);\n                if (true === skip) {\n                    skip = false;\n                    ret_val = ret_buf + ret_val.substr(idx + 1);\n                } else {\n                    ret_val = ret_buf + up_str + ret_val.substr(idx + 2);\n                }\n            }\n            return ret_val;\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n    },\n\n    getColor: function getColor(sty) {\n        try {\n            if ('none' === sty) {\n                return new mofron.Color();\n            } else if (null === sty) {\n                return null;\n            }\n\n            var color = null;\n            if (-1 !== sty.indexOf('rgba(')) {\n                color = sty.substring(5);\n            } else if (-1 !== sty.indexOf('rgb(')) {\n                color = sty.substring(4);\n            } else {\n                return null;\n            }\n\n            color = color.substring(0, color.length - 1);\n            color = color.split(',');\n            if (3 === color.length) {\n                return new mofron.Color(parseInt(color[0]), parseInt(color[1]), parseInt(color[2]));\n            } else if (4 === color.length) {\n                return new mofron.Color(parseInt(color[0]), parseInt(color[1]), parseInt(color[2]), parseInt(color[3]));\n            } else {\n                return null;\n            }\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n    },\n\n    getLength: function getLength(val) {\n        try {\n            if ('string' !== typeof val) {\n                return null;\n            }\n            if (val.length - 2 === val.indexOf('px')) {\n                return parseInt(val.split('px')[0]);\n            }\n            return val;\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n    },\n\n    getCompSize: function getCompSize(cmp) {\n        try {\n            if (false === mofron.func.isInclude(cmp, 'Component')) {\n                throw new Error('invalid parameter');\n            }\n            var wid = null;\n            var hei = null;\n\n            /* get x-value */\n            if ('function' === typeof cmp.width) {\n                wid = cmp.width();\n            } else if ('function' === typeof cmp.size) {\n                wid = cmp.size().width;\n            } else {\n                wid = mofron.func.getLength(cmp.style('width'));\n            }\n\n            /* get y-value */\n            if ('function' === typeof cmp.height) {\n                hei = cmp.height();\n            } else if ('function' === typeof cmp.size) {\n                hei = cmp.size().height;\n            } else {\n                hei = mofron.func.getLength(cmp.style('height'));\n            }\n\n            return {\n                width: wid,\n                height: hei\n            };\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n    },\n\n    getStyleConts: function getStyleConts(sel, cnt) {\n        try {\n            var ret_val = sel + '{';\n            for (var idx in cnt) {\n                ret_val += idx + ':' + cnt[idx] + ';';\n            }\n            return ret_val + '}';\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n    },\n\n    isInclude: function isInclude(obj, nm) {\n        try {\n            if (null === obj || 'object' !== (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) {\n                return false;\n            }\n            if ('function' !== typeof obj.name) {\n                return false;\n            }\n            var chk_nm = 'string' === typeof nm ? [nm] : nm;\n            var chk_idx = 0;\n            var name_lst = obj.getNameList();\n            for (var idx in name_lst) {\n                if (chk_nm[chk_idx] === name_lst[idx]) {\n                    chk_idx++;\n                    if (chk_nm.length === chk_idx) {\n                        return true;\n                    }\n                    continue;\n                }\n                if (0 < chk_idx) {\n                    break;\n                }\n            }\n            return false;\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n    },\n\n    isObject: function isObject(obj, nm) {\n        try {\n            if (null === obj || 'object' !== (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) {\n                return false;\n            }\n            if ('function' !== typeof obj.name) {\n                return false;\n            }\n            if ('string' !== typeof nm) {\n                throw new Error('invalid parameter');\n            }\n\n            if (nm === obj.name()) {\n                return true;\n            }\n            return false;\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n    },\n\n    addHeadConts: function addHeadConts(opt) {\n        try {\n            if ('object' !== (typeof opt === 'undefined' ? 'undefined' : _typeof(opt)) || null === opt) {\n                throw new Error('invalid parameter');\n            }\n\n            var tag = opt.tag;\n            var contents = undefined === opt.contents ? '' : opt.contents;\n            if (undefined === tag || 'string' !== typeof tag) {\n                throw new Error(\"invalid parameter\");\n            }\n\n            /* get attr contents */\n            var set_conts = '';\n            var attr_conts = '';\n            var attr = undefined === opt.attr ? null : opt.attr;\n            for (var key in attr) {\n                attr_conts += key;\n                if (null != attr[key]) {\n                    attr_conts += '=\"' + attr[key] + '\" ';\n                }\n            }\n\n            /* check simple tag */\n            var simple = false;\n            if (undefined === opt.simple) {\n                simple = 'link' === tag || 'meta' === tag || 'base' === tag ? true : false;\n            } else {\n                simple = opt.simple;\n            }\n\n            /* init contents string */\n            var conts_str = '';\n            if ('object' === (typeof contents === 'undefined' ? 'undefined' : _typeof(contents))) {\n                for (var cidx in contents) {\n                    if ('string' !== typeof contents[cidx]) {\n                        throw new Error('invalid parameter');\n                    }\n                    conts_str += contents[cidx];\n                }\n            } else if ('string' === typeof contents) {\n                conts_str = contents;\n            } else {\n                throw new Error('invalid parameter');\n            }\n\n            /* add tag */\n            if (false === simple) {\n                var add_conts = '<' + tag + ' ' + attr_conts + '>' + conts_str + '</' + tag + '>';\n            } else {\n                var add_conts = '<' + tag + ' ' + attr_conts + '>' + conts_str;\n            }\n\n            if (undefined !== mofron.ssr) {\n                mofron.ssr.head(add_conts);\n            } else {\n                document.head.insertAdjacentHTML('beforeend', add_conts);\n            }\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n    },\n\n    addResizeWin: function addResizeWin(func, prm, tlag) {\n        try {\n            var que_buf = null;\n            var param = prm;\n            var time_lag = undefined === tlag ? 200 : tlag;\n            if ('function' !== typeof func || 'number' !== typeof time_lag) {\n                throw new Error('invalid parameter');\n            }\n            window.addEventListener('resize', function () {\n                try {\n                    clearTimeout(que_buf);\n                    que_buf = setTimeout(func, time_lag, param);\n                } catch (e) {\n                    console.error(e.stack);\n                    throw new Error();\n                }\n            }, false);\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n    },\n\n    getTemp: function getTemp(key) {\n        try {\n            return undefined === mofron.temp[key] ? null : mofron.temp[key];\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n    },\n\n    setTemp: function setTemp(key, val) {\n        try {\n            mofron.temp[key] = val;\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n    }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/common/function.js?")},"./node_modules/mofron/src/core/Component.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file   Component.js\n * @author simpart\n */\n\n/**\n * @class Base\n * @brief base component class\n */\nmofron.Component = function (_mofron$Base) {\n    _inherits(_class, _mofron$Base);\n\n    /**\n     * initialize member, adom\n     *\n     * @param po : (object) component parameter / option (not require)\n     */\n    function _class(po) {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));\n\n            _this.name('Component');\n\n            /* initialize member */\n            _this.m_child = new Array();\n            _this.m_adom = null;\n            _this.m_conf = new Array(new Array(), /* layout */\n            new Array(), /* effect */\n            new Array() /* event */\n            );\n            _this.m_target = new Array(null, /* child */\n            null, /* style */\n            null /* event */\n            );\n            _this.prmOpt(po);\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    /*** method ***/\n\n    _createClass(_class, [{\n        key: 'name',\n        value: function name(nm) {\n            try {\n                if (undefined === nm) {\n                    return _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'name', this).call(this);\n                }\n                _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'name', this).call(this, nm);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * child target setter / getter\n         * \n         * @param tgt : (object) dom/adom object\n         * @param idx : (number) set index\n         * @return (object) dom/adom object\n         */\n\n    }, {\n        key: 'target',\n        value: function target(tgt, idx) {\n            try {\n                this.adom();\n                var _idx = undefined === idx ? 0 : idx;\n                if (undefined === tgt) {\n                    /* getter */\n                    if (0 === _idx && null === this.m_target[_idx]) {\n                        if (0 === this.adom().child().length) {\n                            return null;\n                        }\n                        this.target(this.adom().child()[0]);\n                    }\n                    return this.m_target[_idx];\n                }\n                /* setter */\n                if (null === tgt || 'object' !== (typeof tgt === 'undefined' ? 'undefined' : _typeof(tgt))) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_target[_idx] = tgt;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * get style target adom\n         *\n         * @param tgt : (object) dom/adom object\n         * @return (object) dom/adom object\n         */\n\n    }, {\n        key: 'styleTgt',\n        value: function styleTgt(tgt) {\n            try {\n                if (undefined === tgt) {\n                    /* getter */\n                    if (null === this.m_target[1]) {\n                        if (null === this.target()) {\n                            return null;\n                        }\n                        this.target(this.target(), 1);\n                    }\n                    return this.m_target[1];\n                }\n                /* setter */\n                this.target(tgt, 1);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * get event target adom\n         *\n         * @param tgt : (object) dom/adom object\n         * @return (object) dom/adom object\n         */\n\n    }, {\n        key: 'eventTgt',\n        value: function eventTgt(tgt) {\n            try {\n                if (undefined === tgt) {\n                    /* getter */\n                    if (this.target().getId() === this.adom().getId()) {\n                        this.target(this.adom().child()[0], 2);\n                    } else if (null === this.m_target[2]) {\n                        return this.target();\n                    }\n                    return this.m_target[2];\n                }\n                /* setter */\n                return this.target(tgt, 2);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * child component setter / getter\n         * \n         * @param chd : (object) child component\n         * @param chd : (object) child component array\n         * @return (array) : childlen object\n         */\n\n    }, {\n        key: 'child',\n        value: function child(chd) {\n            try {\n                if (undefined === chd) {\n                    /* getter */\n                    this.adom(); // for before initDomConts()\n                    return this.m_child;\n                }\n                /* setter */\n                if ('object' !== (typeof chd === 'undefined' ? 'undefined' : _typeof(chd))) {\n                    this.addChild(chd);\n                    return;\n                }\n\n                var set_chd = null;\n                var set_disp = true;\n                for (var idx in chd) {\n                    this.addChild(chd[idx]);\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'addChild',\n        value: function addChild(chd, idx) {\n            try {\n                if (false === mofron.func.isInclude(chd, 'Component')) {\n                    throw new Error('invalid parameter');\n                }\n\n                /* configure child */\n                chd.theme(null === this.theme() ? undefined : this.theme());\n\n                /* setting parent-child relation */\n                chd.parent(this); // child's parent is me\n                this.target().addChild(chd.adom(), idx); // parent relate to child at dom level\n\n                if (undefined === idx || 0 === this.m_child.length) {\n                    this.m_child.push(chd);\n                } else {\n                    this.m_child.splice(idx, 0, chd);\n                }\n\n                if (null !== this.m_adom && this.adom().isPushed()) {\n                    /* render child */\n                    var lo = this.layout();\n                    for (var lo_idx in lo) {\n                        lo[lo_idx].execute();\n                    }\n                    chd.render();\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'updChild',\n        value: function updChild(o_chd, n_chd) {\n            try {\n                if (false === mofron.func.isInclude(o_chd, 'Component') || false === mofron.func.isInclude(n_chd, 'Component')) {\n                    throw new Error('invalid parameter');\n                }\n\n                /* search index of old-child */\n                var chd = this.child();\n                var upd_idx = null;\n                for (var chd_idx in chd) {\n                    if (chd[chd_idx].getId() === o_chd.getId()) {\n                        upd_idx = chd_idx;\n                        break;\n                    }\n                }\n                if (null === upd_idx) {\n                    throw new Error('invalid parameter');\n                }\n\n                var old_tgt = chd[upd_idx].adom().parent();\n                var buf_tgt = this.target();\n\n                /* replace child */\n                var upd_disp = this.child()[upd_idx].visible();\n                this.child()[upd_idx].destroy();\n\n                this.target(old_tgt);\n                this.addChild(n_chd, upd_idx);\n                this.target(buf_tgt);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /* for destroy */\n\n    }, {\n        key: 'delChild',\n        value: function delChild(idx) {\n            try {\n                if ('number' !== typeof idx || undefined === this.child()[idx]) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_child.splice(idx, 1);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * parent getter / setter\n         *\n         * @param pnt : (object) parent component\n         */\n\n    }, {\n        key: 'parent',\n        value: function parent(pnt) {\n            try {\n                if (undefined === pnt) {\n                    return undefined === this.m_parent ? null : this.m_parent;\n                }\n                if (null !== pnt && false === mofron.func.isInclude(pnt, 'Component')) {\n                    throw new Error('invalid parameter');\n                }\n\n                if (null !== pnt && null !== this.parent() || null !== this.m_adom && true === this.target().isPushed()) {\n                    /* rewrite parent */\n                    this.destroy();\n                }\n                this.m_parent = pnt;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * style getter / setter\n         *\n         * @param kv (object) \n         * @param los (boolean) loose flag\n         * @return (object) style object\n         */\n\n    }, {\n        key: 'style',\n        value: function style(kv, los) {\n            try {\n                if ('string' === typeof kv || undefined === kv) {\n                    /* getter */\n                    return this.styleTgt().style(kv);\n                }\n                /* setter */\n                this.styleTgt().style(kv, los);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'event',\n        value: function event(evt) {\n            try {\n                if (undefined === evt) {\n                    /* getter */\n                    return this.config(2);\n                }\n                /* setter */\n                if ('object' !== (typeof evt === 'undefined' ? 'undefined' : _typeof(evt))) {\n                    this.addEvent(evt);\n                    return;\n                }\n                for (var eidx in evt) {\n                    this.addEvent(evt[eidx]);\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * add component event \n         *\n         * @param evt : (object) event object\n         */\n\n    }, {\n        key: 'addEvent',\n        value: function addEvent(evt) {\n            try {\n                this.addConfig(2, evt);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'layout',\n        value: function layout(lo) {\n            try {\n                if (undefined === lo) {\n                    /* getter */\n                    return this.config(0);\n                }\n                /* setter */\n                if ('object' !== (typeof lo === 'undefined' ? 'undefined' : _typeof(lo))) {\n                    this.addLayout(lo);\n                    return;\n                }\n                for (var lidx in lo) {\n                    this.addLayout(lo[lidx]);\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * add component layout\n         *\n         * @param lo : (object) layout object\n         */\n\n    }, {\n        key: 'addLayout',\n        value: function addLayout(lo) {\n            try {\n                this.addConfig(0, lo);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'effect',\n        value: function effect(eff) {\n            try {\n                if (undefined === eff) {\n                    /* getter */\n                    return this.config(1);\n                }\n                /* setter */\n                if ('object' !== (typeof eff === 'undefined' ? 'undefined' : _typeof(eff))) {\n                    this.addEffect(eff);\n                    return;\n                }\n                for (var eidx in eff) {\n                    this.addEffect(eff[eidx]);\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'getConfig',\n        value: function getConfig(tp, nm) {\n            try {\n                if ('layout' !== tp && 'effect' !== tp && 'event' !== tp) {\n                    throw new Error('invalid type');\n                }\n                var cnf = this[tp]();\n                if (undefined !== nm) {\n                    for (var cidx in cnf) {\n                        if (cnf[cidx].name() === nm) {\n                            return cnf[cidx];\n                        }\n                    }\n                } else {\n                    return cnf;\n                }\n                return null;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'delConfig',\n        value: function delConfig(tp, nm) {\n            try {\n                if ('layout' !== tp && 'effect' !== tp && 'event' !== tp) {\n                    throw new Error('invalid type');\n                }\n                var cnf = this[tp]();\n                if (undefined !== nm) {\n                    for (var cidx in cnf) {\n                        if (cnf[cidx].name() === nm) {\n                            /* delete target */\n                            if ('layout' === tp) {\n                                this.m_conf[0].splice(cidx, 1);\n                            } else if ('effect' === tp) {\n                                this.m_conf[1].splice(cidx, 1);\n                            } else if ('event' === tp) {\n                                this.m_conf[2].splice(cidx, 1);\n                            }\n                        }\n                    }\n                } else {\n                    return cnf;\n                }\n                return null;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'addEffect',\n        value: function addEffect(eff, flg) {\n            try {\n                if (undefined !== eff.speed()) {\n                    /* update effect speed */\n                    var eff_lst = this.effect();\n                    for (var eidx in eff_lst) {\n                        eff_lst[eidx].speed(eff.speed());\n                    }\n                } else {\n                    if (0 !== this.effect().length && undefined !== this.effect()[0].speed()) {\n                        eff.speed(this.effect()[0].speed());\n                    }\n                }\n                if (undefined !== flg) {\n                    eff.defStatus(flg);\n                }\n                this.addConfig(1, eff);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'config',\n        value: function config(idx, cnf) {\n            try {\n                if (undefined === cnf) {\n                    /* getter */\n                    return undefined === this.m_conf[idx] ? null : this.m_conf[idx];\n                }\n                /* setter */\n                if ('object' !== (typeof cnf === 'undefined' ? 'undefined' : _typeof(cnf))) {\n                    throw new Error('invalid parameter');\n                }\n                if (undefined !== cnf[0]) {\n                    for (var cidx in cnf) {\n                        /* set child array */\n                        this.addConfig(idx, cnf[cidx]);\n                    }\n                    return;\n                }\n                this.addConfig(idx, cnf);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'addConfig',\n        value: function addConfig(idx, cnf) {\n            try {\n                if (undefined === this.m_conf[idx] || false === mofron.func.isInclude(cnf, 'CompConf')) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_conf[idx].push(cnf);\n                cnf.target(this);\n                if (true === this.adom().isPushed()) {\n                    if (1 === idx && false === cnf.defStatus()) {\n                        return;\n                    }\n                    cnf.execute();\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * theme setter / getter\n         *\n         * @param thm : (object) theme object\n         * @return (object) theme object\n         */\n\n    }, {\n        key: 'theme',\n        value: function theme(thm) {\n            try {\n                if (undefined === thm) {\n                    /* getter */\n                    if (undefined === this.m_theme) {\n                        this.m_theme = new mofron.Theme({});\n                        this.m_theme.target(this);\n                    }\n                    return this.m_theme;\n                }\n                /* setter */\n                this.theme().setTheme(thm);\n                var chd = this.m_child;\n                for (var idx in chd) {\n                    chd[idx].theme(thm);\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'themeConts',\n        value: function themeConts() {}\n\n        /**\n         * create componrnt DOM\n         * \n         */\n\n    }, {\n        key: 'render',\n        value: function render() {\n            try {\n                /* push contents to DOM */\n                if (null === this.parent()) {\n                    mofron.root.push(this);\n                }\n\n                /* set child config */\n                this.initConfig(0); // layout\n                this.initConfig(1); // effect\n\n                /* before push event */\n                this.beforeRender();\n                this.adom().pushDom(null === this.parent() ? null : this.parent().target());\n                /* after push event */\n                this.afterRender();\n\n                this.initConfig(2); // event\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'beforeRender',\n        value: function beforeRender() {\n            try {\n                var chd = this.child();\n                for (var idx in chd) {\n                    chd[idx].beforeRender();\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'afterRender',\n        value: function afterRender() {\n            try {\n                var chd = this.child();\n                for (var idx in chd) {\n                    chd[idx].afterRender();\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'initConfig',\n        value: function initConfig(tgt_idx) {\n            try {\n                /* set child config */\n                var chd = this.child();\n                for (var cidx in chd) {\n                    chd[cidx].initConfig(tgt_idx);\n                }\n\n                /* set config */\n                var cnf = this.config(tgt_idx);\n                for (var cfidx in cnf) {\n                    cnf[cfidx].execute(1 === tgt_idx ? cnf[cfidx].defStatus() : undefined);\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            try {\n                if (null === this.m_adom) {\n                    throw new Error('not initialized yet');\n                }\n                /* delete at dom level */\n                this.adom().destroy();\n\n                /* delete at component level */\n                if (null !== this.parent()) {\n                    var chd = this.parent().child(); // children from parent\n                    for (var idx in chd) {\n                        if (chd[idx].adom().getId() === this.adom().getId()) {\n                            this.parent().delChild(parseInt(idx)); // separated from parent\n                            break;\n                        }\n                    }\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'initDomContsCtl',\n        value: function initDomContsCtl() {\n            try {\n                if (false === this.isInitDom()) {\n                    this.adom(new mofron.Adom());\n                    this.adom().component(this);\n                    /*** initialize dom contents ***/\n                    if (null === this.param()) {\n                        /* this component is no parameter */\n                        this.initDomConts();\n                    } else {\n                        var cmp_p = this.param().getParam();\n                        /* call init function with parameters specified */\n                        if (1 === cmp_p.length) {\n                            this.initDomConts(cmp_p[0]);\n                        } else if (2 === cmp_p.length) {\n                            this.initDomConts(cmp_p[0], cmp_p[1]);\n                        } else if (3 === cmp_p.length) {\n                            this.initDomConts(cmp_p[0], cmp_p[1], cmp_p[2]);\n                        } else {\n                            throw new Error('too many component parameters');\n                        }\n                    }\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'initDomConts',\n        value: function initDomConts(prm) {\n            try {\n                this.adom().addChild(new mofron.Dom('string' === typeof prm ? prm : 'div', this));\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'isInitDom',\n        value: function isInitDom() {\n            try {\n                return null === this.m_adom ? false : true;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'visible',\n        value: function visible(flg) {\n            try {\n                if (undefined === flg) {\n                    /* getter */\n                    return false === this.isInitDom() || 'none' === this.adom().style('display') ? false : true;\n                }\n                /* setter */\n                if ('boolean' !== typeof flg) {\n                    throw new Error('invalid parameter');\n                }\n\n                if (true === flg) {\n                    if ('none' === this.adom().style('display')) {\n                        this.adom().style({ 'display': null });\n                    }\n                } else {\n                    this.adom().style({ 'display': 'none' });\n                }\n\n                if (null === this.parent()) {\n                    if (false === this.adom().isPushed()) {\n                        this.render();\n                    }\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'vdom',\n        value: function vdom(vd) {\n            return this.adom(vd);\n        }\n\n        /**\n         * agent dom setter / getter\n         * \n         * @return (object) adom object\n         */\n\n    }, {\n        key: 'adom',\n        value: function adom(ad, rdf) {\n            try {\n                if (undefined === ad) {\n                    /* getter */\n                    if (null === this.m_adom) {\n                        this.initDomContsCtl();\n                    }\n                    return this.m_adom;\n                }\n                /* setter */\n                if (false === mofron.func.isInclude(ad, 'Dom')) {\n                    throw new Error('invalid parameter : ' + (typeof ad === 'undefined' ? 'undefined' : _typeof(ad)));\n                }\n                this.m_adom = ad;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'size',\n        value: function size(x, y) {\n            try {\n                if (undefined === x) {\n                    /* getter */\n                    return [this.width(), this.height()];\n                }\n                /* setter */\n                this.width(x);\n                this.height(y);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'width',\n        value: function width(x) {\n            try {\n                if (undefined === x) {\n                    /* getter */\n                    return mofron.func.getLength(this.style('width'));\n                }\n                /* setter */\n                this.style({\n                    'width': 'number' === typeof x ? x + 'px' : x\n                });\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'height',\n        value: function height(y) {\n            try {\n                if (undefined === y) {\n                    /* getter */\n                    return mofron.func.getLength(this.style('height'));\n                }\n                /* setter */\n                this.style({\n                    'height': 'number' === typeof y ? y + 'px' : y\n                });\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'color',\n        value: function color(val) {\n            try {\n                if (undefined === val) {\n                    /* getter */\n                    return undefined === this.m_color ? null : this.m_color;\n                }\n                /* setter */\n                if (true !== mofron.func.isInclude(val, 'Color')) {\n                    throw new Error('invalid parameter');\n                }\n                this.style({\n                    'background': val.getStyle()\n                });\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'execOption',\n        value: function execOption(opt) {\n            try {\n                this.adom();\n                opt = undefined === opt ? this.getOption() : opt;\n                if (null === opt) {\n                    return;\n                }\n                if (undefined !== opt.theme) {\n                    this.theme(opt.theme);\n                    delete opt.theme;\n                }\n                _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'execOption', this).call(this, opt);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Component.js?")},"./node_modules/mofron/src/core/Effect.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file effect/Base.js\n */\n\nmofron.Effect = function (_mofron$CompConf) {\n    _inherits(_class, _mofron$CompConf);\n\n    function _class(po) {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, po));\n\n            _this.name('Effect');\n            _this.m_cb = new Array(null, /* function */\n            null /* parameter */\n            );\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    _createClass(_class, [{\n        key: 'execute',\n        value: function execute(flg) {\n            try {\n                if (true === this.ignore()) {\n                    return;\n                }\n\n                var _flg = flg === undefined ? true : flg;\n                if ('boolean' !== typeof _flg) {\n                    throw new Error('invalid paramter');\n                }\n\n                if (0 === this.speed()) {\n                    if (true === _flg) {\n                        this.enable(this.target());\n                        this.status(true);\n                    } else {\n                        this.disable(this.target());\n                        this.status(false);\n                    }\n                } else {\n                    /* init exec */\n                    if (true === _flg) {\n                        this.disable(this.target());\n                        this.status(false);\n                    } else {\n                        this.enable(this.target());\n                        this.status(true);\n                    }\n\n                    this.setConf(true);\n\n                    setTimeout(function (eff) {\n                        try {\n                            if (true === _flg) {\n                                eff.enable(eff.target());\n                                eff.status(true);\n                            } else {\n                                eff.disable(eff.target());\n                                eff.status(false);\n                            }\n                        } catch (e) {\n                            console.error(e.stack);\n                            throw e;\n                        }\n                    }, 200, this);\n                }\n\n                setTimeout(function (eff) {\n                    try {\n                        if (0 < eff.speed() && eff.getId() === eff.target().effect()[0].getId()) {\n                            eff.setConf(false);\n                        }\n                        if (null != eff.callback()[0]) {\n                            eff.callback()[0](eff.callback()[1]);\n                        }\n                    } catch (e) {\n                        console.error(e.stack);\n                        throw e;\n                    }\n                }, this.speed() * 1000, this);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'setConf',\n        value: function setConf(en) {\n            try {\n                if ('boolean' !== typeof en) {\n                    throw new Error('invalid paramter');\n                }\n                var adom = this.target().adom();\n                if (true === en) {\n                    adom.style({\n                        '-webkit-transition': 1000 * this.speed() + 'ms all linear 0s',\n                        '-moz-transition': 'all ' + 1000 * this.speed() + 'ms',\n                        '-ms-transition': 'all ' + 1000 * this.speed() + 'ms',\n                        '-o-transition': 'all ' + 1000 * this.speed() + 'ms',\n                        'transtion': 1000 * this.speed() + 'ms all linear 0s'\n                    });\n                } else {\n                    adom.style({\n                        '-webkit-transition': null,\n                        '-moz-transition': null,\n                        '-ms-transition': null,\n                        '-o-transition': null,\n                        'transtion': null\n                    });\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'enable',\n        value: function enable(tgt) {\n            console.warn('not implement');\n        }\n    }, {\n        key: 'disable',\n        value: function disable(tgt) {\n            console.warn('not implement');\n        }\n    }, {\n        key: 'status',\n        value: function status(sts) {\n            try {\n                if (undefined === sts) {\n                    /* getter */\n                    return undefined === this.m_sts ? false : this.m_sts;\n                }\n                /* setter */\n                if ('boolean' !== typeof sts) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_sts = sts;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'defStatus',\n        value: function defStatus(sts) {\n            try {\n                if (undefined === sts) {\n                    /* getter */\n                    return undefined === this.m_defsts ? true : this.m_defsts;\n                }\n                /* setter */\n                if ('boolean' !== typeof sts) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_defsts = sts;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'speed',\n        value: function speed(spd) {\n            try {\n                if (undefined === spd) {\n                    /* getter */\n                    return undefined === this.m_speed ? 0 : this.m_speed;\n                }\n                /* setter */\n                if ('number' != typeof spd) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_speed = spd;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'callback',\n        value: function callback(fnc, prm) {\n            try {\n                return this.confFunc(fnc, prm);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'param',\n        value: function param(val) {\n            try {\n                var ret = _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'param', this).call(this, val);\n                if (undefined === ret) {\n                    var prm = val.getParam();\n                    var plen = val.getParam().length;\n                    if (1 === plen) {\n                        this.value(prm[0]);\n                    } else if (2 === plen) {\n                        this.value(prm[0], prm[1]);\n                    } else if (3 === plen) {\n                        this.value(prm[0], prm[1], prm[2]);\n                    } else if (4 === plen) {\n                        this.value(prm[0], prm[1], prm[2], prm[3]);\n                    } else if (5 === plen) {\n                        this.value(prm[0], prm[1], prm[2], prm[3], prm[4]);\n                    }\n                }\n                return ret;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.CompConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Effect.js?")},"./node_modules/mofron/src/core/Event.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file event.js\n * @author simpart\n */\n\n/**\n * @class mofron.event.Base\n * @brief base class of event\n */\nmofron.Event = function (_mofron$CompConf) {\n    _inherits(_class, _mofron$CompConf);\n\n    /**\n     * initialize member\n     *\n     * @param fnc : (option) function for event listener\n     * @param prm : (option) function parameter\n     */\n    function _class(fnc, prm) {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));\n\n            _this.name('Event');\n\n            if ('function' === typeof fnc) {\n                _this.handler(fnc, prm);\n            } else {\n                _this.setPrmOpt(fnc);\n                _this.execOption(undefined === fnc || null === fnc ? {} : fnc);\n            }\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    /**\n     * set function for event listener\n     *\n     * @param fnc : (function) function for event listener\n     * @param prm : (mixed) function parameter (option)\n     */\n\n\n    _createClass(_class, [{\n        key: 'handler',\n        value: function handler(fnc, prm) {\n            try {\n                return this.confFunc(fnc, prm);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'execute',\n        value: function execute() {\n            try {\n                if (true !== this.ignore()) {\n                    this.eventConts(this.target().eventTgt());\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * this is interface function.\n         * extend class needs to implement this function.\n         */\n\n    }, {\n        key: 'eventConts',\n        value: function eventConts(tgt) {\n            try {\n                console.warn('not implement');\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.CompConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Event.js?")},"./node_modules/mofron/src/core/Layout.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file layout/Base.js\n * @brief Base class of layout\n */\n\nmofron.Layout = function (_mofron$CompConf) {\n    _inherits(_class, _mofron$CompConf);\n\n    function _class(po) {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, po));\n\n            _this.name(\'Layout\');\n            _this.m_execnt = 0;\n\n            var opt = _this.getOption();\n            if (null !== opt) {\n                _this.execOption(opt);\n            }\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    _createClass(_class, [{\n        key: \'execute\',\n        value: function execute() {\n            try {\n                if (true === this.ignore()) {\n                    return;\n                }\n                var tgt_chd = this.target().child();\n                var _idx = null;\n                for (var idx in tgt_chd) {\n                    _idx = parseInt(idx);\n                    if (_idx < this.m_execnt) {\n                        continue;\n                    }\n\n                    this.layoutConts(_idx, tgt_chd[_idx]);\n                    this.m_execnt++;\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: \'layoutConts\',\n        value: function layoutConts(idx, tgt) {\n            try {\n                console.warn(\'layout is not implements\');\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.CompConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Layout.js?')},"./node_modules/mofron/src/core/Template.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file Template.js\n * @author simpart\n */\n\nmofron.Template = function (_mofron$Base) {\n    _inherits(_class, _mofron$Base);\n\n    function _class(prm) {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));\n\n            var bs_cmp = function (_mofron$Component) {\n                _inherits(bs_cmp, _mofron$Component);\n\n                function bs_cmp() {\n                    _classCallCheck(this, bs_cmp);\n\n                    return _possibleConstructorReturn(this, (bs_cmp.__proto__ || Object.getPrototypeOf(bs_cmp)).apply(this, arguments));\n                }\n\n                _createClass(bs_cmp, [{\n                    key: 'initTmplConts',\n                    value: function initTmplConts(p) {\n                        try {\n                            p[0].initTmplConts(p[1]);\n                        } catch (e) {\n                            console.error(e.stack);\n                            throw e;\n                        }\n                    }\n                }]);\n\n                return bs_cmp;\n            }(mofron.Component);\n            _this.base(new bs_cmp());\n            _this.name('Template');\n            _this.base().initTmplConts([_this, prm]);\n\n            var tmp = _this.getNameList();\n            var tmp_str = 'mofron-tmpl-';\n            for (var tidx in tmp) {\n                if (0 == tidx) {\n                    continue;\n                } else if (1 != tidx) {\n                    tmp_str += '-';\n                }\n                if ('i' !== 'I'.toLowerCase()) {\n                    tmp_str += tmp[tidx].replace(/[A-Z]/g, function (ch) {\n                        return String.fromCharCode(ch.charCodeAt(0) | 32);\n                    });\n                } else {\n                    tmp_str += tmp[tidx].toLowerCase();\n                }\n            }\n            if ('mofron-tmpl-' !== tmp_str) {\n                _this.base().target().attr({ 'template': tmp_str });\n            }\n\n            _this.setPrmOpt(prm);\n            _this.execOption();\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    _createClass(_class, [{\n        key: 'name',\n        value: function name(nm) {\n            try {\n                if (undefined === nm) {\n                    return _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'name', this).call(this);\n                }\n                _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'name', this).call(this, nm);\n                var tmp_atr = this.base().target().attr('template');\n                var set_nm = null;\n                if (null !== tmp_atr) {\n                    if ('i' !== 'I'.toLowerCase()) {\n                        set_nm = nm.replace(/[A-Z]/g, function (ch) {\n                            return String.fromCharCode(ch.charCodeAt(0) | 32);\n                        });\n                    } else {\n                        set_nm = nm.toLowerCase();\n                    }\n                    this.base().target().attr({ 'template': tmp_atr + '-' + set_nm });\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'base',\n        value: function base(bs) {\n            try {\n                if (undefined === bs) {\n                    /* getter */\n                    return undefined === this.m_base ? null : this.m_base;\n                }\n                /* setter */\n                if (false === mofron.func.isInclude(bs, 'Component')) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_base = bs;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'title',\n        value: function title(val) {\n            try {\n                if (undefined === val) {\n                    /* getter */\n                    return undefined === this.m_title ? null : this.m_title;\n                }\n                /* setter */\n                mofron.func.addHeadConts({\n                    tag: 'title',\n                    contents: val\n                });\n                this.m_title = val;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'theme',\n        value: function theme(thm) {\n            try {\n                if (undefined === thm) {\n                    /* getter */\n                    return this.base().theme();\n                }\n                /* setter */\n                this.base().theme(thm);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'initTmplConts',\n        value: function initTmplConts(prm) {\n            try {\n                console.log('not implements');\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'visible',\n        value: function visible(flg, eff) {\n            try {\n                return this.base().visible(flg, eff);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Template.js?")},"./node_modules/mofron/src/util/Color.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file  Color.js\n * @author simpart\n */\n\n/**\n * @class Color\n * @brief Color Defined Class\n */\nmofron.Color = function (_mofron$Base) {\n    _inherits(_class, _mofron$Base);\n\n    /**\n     * initialize member\n     *\n     * @param r : (number 0-255) red value (option)\n     * @param g : (number 0-255) green value (option)\n     * @param b : (number 0-255) blue alue (option)\n     * @param a : (number 0-1)   alpha value (option)\n     */\n    function _class(r, g, b, a) {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));\n\n            _this.name('Color');\n\n            _this.m_rgba = new Array(null, /* red */\n            null, /* green */\n            null, /* blue */\n            null /* alpha */\n            );\n            _this.rgba(r, g, b, a);\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    /**\n     * get rgba value\n     * \n     * @return (object) rgba array object\n     *   [0] -> (number) red value\n     *   [1] -> (number) green value\n     *   [2] -> (number) blue value\n     *   [3] -> (number) alpha value\n     */\n\n\n    _createClass(_class, [{\n        key: 'rgba',\n        value: function rgba(red, green, blue, alpha) {\n            try {\n                if (undefined === red) {\n                    /* getter */\n                    return this.m_rgba;\n                }\n                /* setter */\n                var _red = red === undefined ? null : red;\n                var _green = green === undefined ? null : green;\n                var _blue = blue === undefined ? null : blue;\n                var _alpha = alpha === undefined ? 1 : alpha;\n\n                if (null === _red && null === _green && null === _blue) {} else if (null !== _red && null !== _green && null !== _blue) {\n                    if ('number' !== typeof _red || 'number' !== typeof _green || 'number' !== typeof _blue) {\n                        throw new Error('invalid parameter');\n                    }\n                } else {\n                    throw new Error('invalid parameter');\n                }\n\n                if ('number' !== typeof _alpha) {\n                    throw new Error('invalid parameter');\n                }\n\n                this.m_rgba[0] = _red;\n                this.m_rgba[1] = _green;\n                this.m_rgba[2] = _blue;\n                this.m_rgba[3] = _alpha;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * get coloe style value\n         *\n         * @return (string) rgba(x,x,x,x)\n         * @return (string) none\n         * @note return 'none' if rgb is null.\n         */\n\n    }, {\n        key: 'getStyle',\n        value: function getStyle() {\n            try {\n                var rgba = this.rgba();\n                var red = rgba[0];\n                var green = rgba[1];\n                var blue = rgba[2];\n                var alpha = rgba[3];\n\n                if (null === red && null === green && null === blue) {\n                    return 'none';\n                }\n                return 'rgba(' + red + ',' + green + ',' + blue + ',' + alpha + ')';\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/Color.js?")},"./node_modules/mofron/src/util/Font.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file  Font.js\n * @author simpart\n */\n\n/**\n * @class Font\n * @brief Font Defined Class\n */\nmofron.Font = function (_mofron$Base) {\n    _inherits(_class, _mofron$Base);\n\n    /**\n     * initialize font\n     *\n     * @param fnt : (string) font name\n     */\n    function _class(fnt, pth) {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));\n\n            _this.name('Font');\n\n            /* check parameter */\n            var _pth = pth === undefined ? null : pth;\n            if ('string' !== typeof fnt) {\n                throw new Error('invalid parameter');\n            }\n\n            /* initialize member */\n            _this.m_family = {};\n            _this.m_class = 'mofron-theme-' + mofron.func.getId(_this);\n            _this.m_theme = false;\n\n            /* initialize function */\n            _this.family(fnt);\n            if (null !== _pth) {\n                _this.setFace(fnt, _pth);\n            }\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    /**\n     * set @font-face\n     * \n     * @param fnt : (string) font name\n     * @param pth : (string) path to font file\n     */\n\n\n    _createClass(_class, [{\n        key: 'setFace',\n        value: function setFace(fnt, pth) {\n            try {\n                if ('string' !== typeof pth || 'string' !== typeof fnt) {\n                    throw new Error('invalid parameter');\n                }\n\n                /* format */\n                var pth_spt = pth.split('.');\n                var format = '';\n                if ('woff' === pth_spt[pth_spt.length - 1]) {\n                    format = \"format('woff')\";\n                } else if ('ttf' === pth_spt[pth_spt.length - 1]) {\n                    format = \"format('truetype')\";\n                } else if ('otf' === pth_spt[pth_spt.length - 1]) {\n                    format = \"format('opentype')\";\n                } else if ('eot' === pth_spt[pth_spt.length - 1]) {\n                    format = \"format('embedded-opentype')\";\n                } else if ('svg' === pth_spt[pth_spt.length - 1] || 'svgz' === pth_spt[pth_spt.length - 1]) {\n                    format = \"format('svg')\";\n                }\n\n                var style = {\n                    'font-family': fnt,\n                    'src': \"url('\" + pth + \"') \" + format\n                };\n                mofron.func.addHeadConts({\n                    tag: 'style',\n                    contents: mofron.func.getStyleConts('@font-face', style)\n                });\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'family',\n        value: function family(fm) {\n            try {\n                if (undefined === fm) {\n                    /* getter */\n                    var ret_val = new Array();\n                    for (var idx in this.m_family) {\n                        ret_val.push(idx);\n                    }\n                    return ret_val;\n                }\n                /* setter */\n                if ('string' !== typeof fm) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_family[fm] = null;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'getFamilyStyle',\n        value: function getFamilyStyle() {\n            try {\n                var fm = this.family();\n                var fm_str = '';\n                for (var idx in fm) {\n                    if ('' !== fm_str) {\n                        fm_str += ',';\n                    }\n                    fm_str += fm[idx];\n                }\n                return fm_str;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * set own font style to style tag.\n         */\n\n    }, {\n        key: 'pushTheme',\n        value: function pushTheme() {\n            try {\n                if (true === this.m_theme) {\n                    return;\n                }\n                var style = {\n                    'font-family': this.getFamilyStyle()\n                };\n                mofron.func.addHeadConts({\n                    tag: 'style',\n                    contents: mofron.func.getStyleConts('.' + this.m_class, { 'font-family': this.getFamilyStyle() })\n                });\n                this.m_theme = true;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'className',\n        value: function className(cls) {\n            try {\n                if (undefined === cls) {\n                    /* getter */\n                    return this.m_class;\n                }\n                /* setter */\n                if ('string' !== typeof cls) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_class = cls;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * set font-family style to target component\n         * \n         * @param (object) : target object\n         */\n\n    }, {\n        key: 'setFont',\n        value: function setFont(tgt) {\n            try {\n                var _tgt = tgt === undefined ? null : tgt;\n                if (null === _tgt || 'object' !== (typeof _tgt === 'undefined' ? 'undefined' : _typeof(_tgt))) {\n                    throw new Error('invalid parameter');\n                }\n\n                if (true === this.m_theme) {\n                    tgt.target().className(this.className());\n                } else {\n                    tgt.style('font-family', this.getFamilyStyle());\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.Base);\nmofron.font = {};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/Font.js?")},"./node_modules/mofron/src/util/Theme.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file theme.js\n * @author simpart\n */\n/**\n * @class mofron.theme\n * @brief theme defined class\n */\nmofron.Theme = function (_mofron$Base) {\n    _inherits(_class, _mofron$Base);\n\n    /**\n     * initialize member\n     */\n    function _class(po) {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, po));\n\n            _this.name('Theme');\n            _this.m_conts = {};\n            _this.execOption();\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    _createClass(_class, [{\n        key: 'target',\n        value: function target(tgt) {\n            try {\n                if (undefined === tgt) {\n                    /* getter */\n                    return undefined === this.m_target ? null : this.m_target;\n                }\n                /* setter */\n                if (false === mofron.func.isInclude(tgt, 'Component')) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_target = tgt;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'override',\n        value: function override(flg) {\n            try {\n                if (undefined === flg) {\n                    /* getter */\n                    return undefined === this.m_over ? true : this.m_over;\n                }\n                /* setter */\n                if ('boolean' !== typeof flg) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_over = flg;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * set theme contents\n         * \n         * @param thm : (mofron.theme object) theme\n         */\n\n    }, {\n        key: 'setTheme',\n        value: function setTheme(thm) {\n            try {\n                if (false === mofron.func.isObject(thm, 'Theme')) {\n                    throw new Error('invalid parameter');\n                }\n                var thm_cnt = thm.get();\n                var set_flg = false;\n                for (var cnt_key in thm_cnt) {\n                    for (var idx in thm_cnt[cnt_key]) {\n                        var _idx = parseInt(idx);\n                        if (null === thm_cnt[cnt_key][_idx]) {\n                            /* skip null contents */\n                            continue;\n                        }\n\n                        if (false === this.override() && null !== this.get(cnt_key, _idx)) {\n                            continue;\n                        }\n\n                        this.set(cnt_key, thm_cnt[cnt_key][_idx], _idx);\n                        set_flg = true;\n                    }\n                }\n                if (null === this.target()) {\n                    throw new Error('could not find target component');\n                }\n                this.target().themeConts(this);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'style',\n        value: function style(kv, idx) {\n            try {\n                if (undefined === kv || 'number' === typeof kv) {\n                    /* getter */\n                    return this.get('Style', kv);\n                }\n                /* setter */\n                if ('object' !== (typeof kv === 'undefined' ? 'undefined' : _typeof(kv))) {\n                    throw new Error('invalid parameter');\n                }\n                var style = this.get('Style');\n                for (var kv_idx in kv) {\n                    style[kv_idx] = kv[kv_idx];\n                }\n                this.set('Style', style, idx, false);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'color',\n        value: function color(clr, idx) {\n            try {\n                if (undefined === clr || 'number' === typeof clr) {\n                    /* getter */\n                    return this.get('Color', clr);\n                }\n                /* setter */\n                if (false === mofron.func.isObject(clr, 'Color')) {\n                    if ('object' === (typeof clr === 'undefined' ? 'undefined' : _typeof(clr)) && undefined !== clr[0]) {\n                        for (var clr_idx in clr) {\n                            this.color(clr[clr_idx], parseInt(clr_idx));\n                        }\n                        return;\n                    }\n                    throw new Error('invalid parameter');\n                }\n                this.set('Color', clr, idx);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'component',\n        value: function component(key, cmp, po) {\n            try {\n                if (undefined === cmp) {\n                    /* getter */\n                    var thm_cmp = this.get(key, 0);\n                    if (null !== thm_cmp) {\n                        return undefined === thm_cmp[1] ? new thm_cmp[0]() : new thm_cmp[0](thm_cmp[1]);\n                    }\n                    return null;\n                }\n                /* setter */\n                if ('function' !== typeof cmp) {\n                    throw new Error('invalid parameter');\n                }\n                this.set(key, [cmp, po], 0);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'font',\n        value: function font(fnt, idx) {\n            try {\n                if (undefined === fnt || 'number' == typeof fnt) {\n                    /* getter */\n                    return this.get('Font', fnt);\n                }\n                /* setter */\n                if (false === mofron.func.isInclude(fnt, 'Font')) {\n                    if ('object' === (typeof fnt === 'undefined' ? 'undefined' : _typeof(fnt)) && undefined !== fnt[0]) {\n                        for (var fnt_idx in fnt) {\n                            this.font(fnt[fnt_idx], parseInt(fnt_idx));\n                        }\n                        return;\n                    }\n                    throw new Error('invalid parameter');\n                }\n                fnt.pushTheme();\n                this.set('Font', fnt, idx);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * get theme contents\n         * \n         * @param key : (string) theme identify key (option)\n         * @param idx : (number) get index (option)\n         * @return (object) theme value\n         */\n\n    }, {\n        key: 'get',\n        value: function get(key, idx) {\n            try {\n                if (undefined === key) {\n                    return this.m_conts;\n                } else if ('string' !== typeof key) {\n                    throw new Error('invalid parameter');\n                }\n\n                var _idx = undefined === idx ? null : idx;\n                if (null === _idx) {\n                    return undefined === this.m_conts[key] ? null : this.m_conts[key];\n                } else {\n                    if (undefined === this.m_conts[key]) {\n                        return null;\n                    }\n                    return undefined === this.m_conts[key][_idx] ? null : this.m_conts[key][_idx];\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * set theme contents\n         * \n         * @param key  : (string) theme contetent key\n         * @param val  : (object) theme element\n         * @param idx  : (number) set index\n         */\n\n    }, {\n        key: 'set',\n        value: function set(key, val, idx) {\n            try {\n                var _val = val === undefined ? null : val;\n                var _idx = idx === undefined ? 0 : idx;\n\n                if ('string' !== typeof key || null === _val || 'number' !== typeof _idx || 0 > _idx) {\n                    throw new Error('invalid parameter');\n                }\n\n                if (undefined === this.m_conts[key]) {\n                    this.m_conts[key] = new Array();\n                }\n\n                var loop = 0;\n                var set_flg = false;\n                for (; loop < 10; loop++) {\n                    if (_idx === this.m_conts[key].length) {\n                        this.m_conts[key].push(val);\n                        set_flg = true;\n                        break;\n                    } else if (_idx < this.m_conts[key].length) {\n                        this.m_conts[key][_idx] = val;\n                        set_flg = true;\n                        break;\n                    } else {\n                        this.m_conts[key].push(null);\n                    }\n                }\n                if (false === set_flg) {\n                    throw new Error('invalid parameter');\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * remove theme value\n         *\n         * @param key : (string) theme identify key\n         * @param idx : (number) remove index\n         */\n\n    }, {\n        key: 'del',\n        value: function del(key, idx) {\n            try {\n                if (undefined === this.m_conts[key][idx]) {\n                    throw new Error('invalid parameter');\n                }\n\n                var cnt = 0;\n                for (var cnt_key in this.m_conts) {\n                    if (cnt_key === key) {\n                        this.m_conts[cnt_key].splice(idx, 1);\n                        if (0 === this.m_conts[cnt_key].length) {\n                            this.m_conts.splice(cnt, 1);\n                        }\n                        return;\n                    }\n                    cnt++;\n                }\n\n                throw new Error('invalid parameter');\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/Theme.js?")},"./node_modules/mofron/src/util/conf/Attr.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file Attr.js\n * @author simpart\n */\n\n/**\n * @class Attr\n * @brief tag attribute object\n */\nmofron.Attr = function (_mofron$DomConf) {\n    _inherits(_class, _mofron$DomConf);\n\n    /**\n     * initialize member\n     *\n     * @param tgt : (object) target adom object\n     */\n    function _class(tgt) {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, tgt));\n\n            _this.name('Attr');\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    /**\n     * set style\n     *\n     * @param key : (string) style key\n     * @param val : (string) style value\n     */\n\n\n    _createClass(_class, [{\n        key: 'rset',\n        value: function rset(key, val) {\n            try {\n                this.target().getRawDom().setAttribute(key, val);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * get attribute value from rawdom\n         *\n         * @param key : (string) style key\n         * @return (object) style contents\n         * @return (string) style contents value\n         */\n\n    }, {\n        key: 'rget',\n        value: function rget(key) {\n            try {\n                var val = this.target().getRawDom().getAttribute(key);\n                return '' === val ? null : val;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'getString',\n        value: function getString() {\n            try {\n                var ret_val = '';\n                for (var idx in this.m_conts) {\n                    if ('' !== ret_val) {\n                        ret_val += ' ';\n                    }\n                    ret_val += null === this.m_conts[idx] ? idx : idx + '=\"' + this.m_conts[idx] + '\"';\n                }\n                return ret_val;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.DomConf);\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/conf/Attr.js?")},"./node_modules/mofron/src/util/conf/ClassName.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file ClassName.js\n * @author simpart\n */\n\n/**\n * @class ClassName\n * @brief classname for tag object\n */\nmofron.ClassName = function (_mofron$DomConf) {\n    _inherits(_class, _mofron$DomConf);\n\n    /**\n     * initialize member\n     *\n     * @param tgt : (object) target adom object\n     */\n    function _class(tgt) {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, tgt));\n\n            _this.name('ClassName');\n            _this.protect(true);\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    _createClass(_class, [{\n        key: 'add',\n        value: function add(nm) {\n            try {\n                var set_obj = {};\n                set_obj[nm] = null;\n                this.set(set_obj);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'get',\n        value: function get() {\n            try {\n                var ret_val = _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'get', this).call(this);\n                if (null === ret_val) {\n                    return null;\n                } else if (undefined === ret_val[0]) {\n                    var ret_obj = new Array();\n                    for (var idx in ret_val) {\n                        ret_obj.push(idx);\n                    }\n                    return ret_obj;\n                } else {\n                    return ret_val;\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * set class name to rowdom\n         *\n         * @param key : (string) style key\n         * @param val : (string) style value\n         */\n\n    }, {\n        key: 'rset',\n        value: function rset(key, val) {\n            try {\n                this.target().getRawDom().classList.add(key);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * get class name from rawdom\n         *\n         * @param key : unused\n         * @return (object) style contents\n         * @return (string) style contents value\n         */\n\n    }, {\n        key: 'rget',\n        value: function rget(key) {\n            try {\n                var clnm = this.target().getRawDom().className;\n                if (undefined === clnm || null === clnm || '' === clnm) {\n                    return null;\n                }\n                return clnm.split(' ');\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'getString',\n        value: function getString() {\n            try {\n                var ret_val = '';\n                var conts = this.get();\n                for (var idx in conts) {\n                    if ('' !== ret_val) {\n                        ret_val += ' ';\n                    }\n                    ret_val += conts[idx];\n                }\n                if ('' === ret_val) {\n                    return '';\n                }\n                return 'class=\"' + ret_val + '\"';\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.DomConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/conf/ClassName.js?")},"./node_modules/mofron/src/util/conf/CompConf.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file CompConf.js\n * @author simpart\n */\n/**\n * @class CompConf\n * @brief Interface of Component Config\n */\nmofron.CompConf = function (_mofron$Base) {\n    _inherits(_class, _mofron$Base);\n\n    function _class(po) {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, po));\n\n            _this.name('CompConf');\n            _this.m_func = new Array(null, null);\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    _createClass(_class, [{\n        key: 'target',\n        value: function target(tgt) {\n            try {\n                if (undefined === tgt) {\n                    /* getter */\n                    return undefined === this.m_target ? null : this.m_target;\n                }\n                /* setter */\n                if (false === mofron.func.isInclude(tgt, 'Component')) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_target = tgt;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'execute',\n        value: function execute() {\n            console.warn('not implement');\n        }\n    }, {\n        key: 'confFunc',\n        value: function confFunc(fnc, prm) {\n            try {\n                if (undefined === fnc) {\n                    /* getter */\n                    return this.m_func;\n                }\n                /* setter */\n                if ('function' !== typeof fnc) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_func[0] = fnc;\n                this.m_func[1] = undefined === prm ? null : prm;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'ignore',\n        value: function ignore(flg) {\n            try {\n                if (undefined === flg) {\n                    /* getter */\n                    return undefined === this.m_cpcf_ign ? false : this.m_cpcf_ign;\n                }\n                /* setter */\n                if ('boolean' !== typeof flg) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_cpcf_ign = flg;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/conf/CompConf.js?")},"./node_modules/mofron/src/util/conf/DomConf.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file DomConf.js\n * @author simpart\n */\n\n/**\n * @class DomConf\n * @brief key-val manage for dom object\n */\nmofron.DomConf = function (_mofron$Base) {\n    _inherits(_class, _mofron$Base);\n\n    function _class(tgt) {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));\n\n            _this.name('DomConf');\n            _this.m_conts = {};\n            _this.target(tgt);\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    _createClass(_class, [{\n        key: 'target',\n        value: function target(tgt) {\n            try {\n                if (undefined === tgt) {\n                    /* getter */\n                    return undefined === this.m_target ? null : this.m_target;\n                }\n                /* setter */\n                if (false === mofron.func.isInclude(tgt, 'Dom')) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_target = tgt;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'set',\n        value: function set(kv) {\n            try {\n                if (undefined === kv || 'object' !== (typeof kv === 'undefined' ? 'undefined' : _typeof(kv))) {\n                    throw new Error('invalid parameter');\n                }\n\n                for (var idx in kv) {\n                    if (true === this.protect() && undefined !== this.m_conts[idx]) {\n                        return;\n                    }\n                    this.m_conts[idx] = kv[idx];\n                    if (true === this.target().isPushed()) {\n                        /* target is already rendered */\n                        this.rset(idx, kv[idx]);\n                    }\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'get',\n        value: function get(key) {\n            try {\n                if (false === this.target().isPushed()) {\n                    if (undefined === key) {\n                        return this.m_conts;\n                    }\n                    return undefined === this.m_conts[key] ? null : this.m_conts[key];\n                } else {\n                    /* target is already rendered */\n                    return undefined == this.rget(key) ? null : this.rget(key);\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'rset',\n        value: function rset() {\n            try {\n                console.warn('not implement');\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'rget',\n        value: function rget() {\n            try {\n                console.warn('not implement');\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'protect',\n        value: function protect(prt) {\n            try {\n                if (undefined === prt) {\n                    /* getter */\n                    return undefined === this.m_protect ? false : this.m_protect;\n                }\n                /* setter */\n                if ('boolean' !== typeof prt) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_protect = prt;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/conf/DomConf.js?")},"./node_modules/mofron/src/util/conf/Prop.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file Prop.js\n * @author simpart\n */\n\n/**\n * @class Prop\n * @brief dom property object\n */\nmofron.Prop = function (_mofron$DomConf) {\n    _inherits(_class, _mofron$DomConf);\n\n    /**\n     * initialize member\n     *\n     * @param tgt : (object) target dom object\n     */\n    function _class(tgt) {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, tgt));\n\n            _this.name(\'Prop\');\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    /**\n     * set property\n     *\n     * @param key : (string) property key\n     * @param val : (string) property value\n     */\n\n\n    _createClass(_class, [{\n        key: \'rset\',\n        value: function rset(key, val) {\n            try {\n                if (undefined === this.target().getRawDom()[key]) {\n                    throw new Error(key + \' is unknown property\');\n                }\n                this.target().getRawDom()[key] = val;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * get property value from rawdom\n         *\n         * @param key : (string) property key\n         * @return (string) property value\n         */\n\n    }, {\n        key: \'rget\',\n        value: function rget(key) {\n            try {\n                return this.target().getRawDom()[key];\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.DomConf);\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/conf/Prop.js?')},"./node_modules/mofron/src/util/conf/Style.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file Style.js\n * @author simpart\n */\n\n/**\n * @class Style\n * @brief component style class\n */\nmofron.Style = function (_mofron$DomConf) {\n    _inherits(_class, _mofron$DomConf);\n\n    /**\n     * initialize member\n     *\n     * @param tgt : (object) target adom object\n     */\n    function _class(tgt) {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, tgt));\n\n            _this.name('Style');\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    /**\n     * set style\n     *\n     * @param key : (string) style key\n     * @param val : (string) style value\n     */\n\n\n    _createClass(_class, [{\n        key: 'rset',\n        value: function rset(key, val) {\n            try {\n                this.target().getRawDom().style[mofron.func.getCamel(key)] = val;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * get style value from rawdom\n         *\n         * @param key : (string) style key\n         * @return (object) style contents\n         * @return (string) style contents value\n         */\n\n    }, {\n        key: 'rget',\n        value: function rget(key) {\n            try {\n                var val = this.target().getRawDom().style[key];\n                return undefined === val ? null : val;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'getString',\n        value: function getString() {\n            try {\n                var ret_val = '';\n                for (var idx in this.m_conts) {\n                    ret_val += idx + ':' + this.m_conts[idx] + ';';\n                }\n                if ('' === ret_val) {\n                    return '';\n                }\n                return 'style=\"' + ret_val + '\"';\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.DomConf);\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/conf/Style.js?")},"./node_modules/mofron/src/util/dom/Adom.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file Adom.js\n * @author simpart\n */\n\n/**\n * @class Adom\n * @brief agent dom class\n */\nmofron.Adom = function (_mofron$Dom) {\n    _inherits(_class, _mofron$Dom);\n\n    /**\n     * initialize member\n     *\n     * @param tag : (string) tag name\n     * @param cmp : (object) component object\n     */\n    function _class() {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));\n\n            _this.name('Adom');\n            _this.m_style = {};\n            _this.m_classnm = {};\n            _this.m_attr = {};\n            _this.m_prop = {};\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    /**\n     * tag name setter / getter to(from) children\n     * \n     * @param tg : (string) tag name (option)\n     * @return (string,null) tag name\n     */\n\n\n    _createClass(_class, [{\n        key: 'tag',\n        value: function tag(tg) {\n            try {\n                if (undefined === tg) {\n                    /* getter */\n                    return null === this.parent() ? null : this.parent().tag();\n                }\n                throw new Error('tag set is not supported at adom');\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'addChild',\n        value: function addChild(chd, idx) {\n            try {\n                if (true === mofron.func.isObject(chd, 'Dom')) {\n                    /* set config */\n                    chd.attr(this.attr());\n                    chd.style(this.style());\n                    chd.prop(this.prop());\n                    chd.className('' === this.className() ? undefined : this.className());\n                    chd.text('' === this.text() ? undefined : this.text());\n                }\n                _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'addChild', this).call(this, chd, idx);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * style setter / getter to(from) children\n         *\n         * @param kv : (object) key value object\n         * @param los : (boolean) loose flag (not require)\n         * @return (string) : style value\n         * @return (object) : style object\n         */\n\n    }, {\n        key: 'style',\n        value: function style(kv, los) {\n            try {\n                if (undefined === kv) {\n                    /* getter */\n                    return this.m_style;\n                }\n                if ('string' === typeof kv) {\n                    /* getter */\n                    return undefined === this.m_style[kv] ? null : this.m_style[kv];\n                }\n                /* setter */\n                var chd = this.child();\n                for (var idx in chd) {\n                    chd[idx].style(kv, los);\n                }\n                for (var idx in kv) {\n                    this.m_style[idx] = kv[idx];\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * tag attribute setter / getter\n         *\n         * @param kv : (object) key value object\n         * @return (string,null) attribute value \n         */\n\n    }, {\n        key: 'attr',\n        value: function attr(kv, val) {\n            try {\n                if ('object' === (typeof kv === 'undefined' ? 'undefined' : _typeof(kv))) {\n                    for (var idx in kv) {\n                        this.m_attr[idx] = kv[idx];\n                    }\n                    var chd = this.child();\n                    for (var idx in chd) {\n                        chd[idx].attr(kv, val);\n                    }\n                } else {\n                    if (undefined === kv) {\n                        return this.m_attr;\n                    }\n                    return undefined === this.m_attr[kv] ? null : this.m_attr[kv];\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * dom property setter / getter\n         * \n         * @param kv (object) key value object\n         * @param val (mix) property value\n         */\n\n    }, {\n        key: 'prop',\n        value: function prop(kv) {\n            try {\n                if ('object' === (typeof kv === 'undefined' ? 'undefined' : _typeof(kv))) {\n                    for (var idx in kv) {\n                        this.m_prop[idx] = kv[idx];\n                    }\n                    var chd = this.child();\n                    for (var idx in chd) {\n                        chd[idx].prop(kv);\n                    }\n                } else {\n                    if (undefined === kv) {\n                        return this.m_prop;\n                    }\n                    return undefined === this.m_prop[kv] ? null : this.m_prop[kv];\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * add tag class name\n         * \n         * @param name : (string) class name\n         */\n\n    }, {\n        key: 'className',\n        value: function className(name) {\n            try {\n                if (undefined === name) {\n                    /* getter */\n                    var ret_val = '';\n                    for (var idx in this.m_classnm) {\n                        if ('' === ret_val) {\n                            ret_val += ' ';\n                        }\n                        ret_val += this.m_classnm[idx];\n                    }\n                    return ret_val;\n                }\n                /* setter */\n                if ('string' !== typeof name) {\n                    throw new Error('invalid parameter');\n                }\n                var chd = this.child();\n                for (var idx in chd) {\n                    chd[idx].className(name);\n                }\n                this.m_classnm[name] = null;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * tag contents text setter / getter\n         * \n         * @param cnt : (string) tag contents (option)\n         * @return (string) tag contents\n         */\n\n    }, {\n        key: 'text',\n        value: function text(txt) {\n            try {\n                if (undefined === txt) {\n                    /* getter */\n                    return undefined === this.m_text ? '' : this.m_text;\n                }\n                /* setter */\n                if ('string' !== typeof txt) {\n                    throw new Error('invalid parameter');\n                }\n                var chd = this.child();\n                for (var idx in chd) {\n                    chd[idx].text(txt);\n                }\n                this.m_text = txt;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * get dom string\n         *\n         * @return (string) dom string\n         */\n\n    }, {\n        key: 'value',\n        value: function value(val) {\n            try {\n                if (undefined !== val) {\n                    return;\n                }\n\n                var ret_val = '';\n                /* get child value */\n                if (0 != this.child().length) {\n                    var chd = this.child();\n                    for (var idx in chd) {\n                        ret_val += chd[idx].value();\n                    }\n                }\n                return ret_val;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * update adom status\n         * \n         * @note update status also child adom\n         */\n\n    }, {\n        key: 'setPushed',\n        value: function setPushed() {\n            try {\n                /* set rawdom */\n                this.m_rawdom = null === this.parent() ? document.body : this.parent().getRawDom();\n\n                /* set property */\n                var prop = this.m_prop;\n                for (var idx in prop) {\n                    this.prop(idx, prop[idx]);\n                }\n\n                if (0 != this.child().length) {\n                    var chd = this.child();\n                    for (var idx in chd) {\n                        chd[idx].setPushed();\n                    }\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * get parent's  pushed dom object from blowser\n         *\n         * @return (object) raw dom object\n         */\n\n    }, {\n        key: 'getRawDom',\n        value: function getRawDom() {\n            try {\n                if (false === this.isPushed()) {\n                    throw new Error('this adom is not rendered yet');\n                }\n                return this.m_rawdom;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            try {\n                var chd = this.child();\n                for (var idx in chd) {\n                    chd[idx].destroy(); // delete rawdom\n                }\n\n                // delete parent relating\n                if (true === mofron.func.isObject(this.parent(), 'Dom')) {\n                    var pchd = this.parent().child();\n                    for (var pidx in pchd) {\n                        if (pchd[pidx].getId() === this.getId()) {\n                            this.parent().delChild(parseInt(pidx));\n                        }\n                    }\n                }\n                this.m_rawdom = null;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.Dom);\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/dom/Adom.js?")},"./node_modules/mofron/src/util/dom/Dom.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @file Dom.js\n * @author simpart\n */\n/**\n * @class Dom\n * @brief Dom class\n */\nmofron.Dom = function (_mofron$Base) {\n    _inherits(_class, _mofron$Base);\n\n    /**\n     * initialize member\n     *\n     * @param tag : (string) tag name\n     * @param cmp : (object) component object\n     */\n    function _class(tg, cmp) {\n        _classCallCheck(this, _class);\n\n        try {\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));\n\n            _this.name('Dom');\n\n            _this.m_classnm = new mofron.ClassName(_this);\n            _this.m_child = new Array();\n            _this.m_style = new mofron.Style(_this);\n            _this.m_attr = new mofron.Attr(_this);\n            _this.m_prop = new mofron.Prop(_this);\n            _this.m_cnflis = new Array();\n            _this.m_rawdom = null;\n\n            _this.prmOpt(tg, cmp);\n            if (null !== _this.param()) {\n                _this.tag(tg);\n                _this.component(cmp);\n            }\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n        return _this;\n    }\n\n    /**\n     * tag name setter / getter\n     *\n     * @param tg : (string) tag name (option)\n     * @return (string) tag name\n     */\n\n\n    _createClass(_class, [{\n        key: 'tag',\n        value: function tag(tg) {\n            try {\n                if (undefined === tg) {\n                    /* getter */\n                    return undefined === this.m_tag ? null : this.m_tag;\n                }\n                /* setter */\n                if ('string' !== typeof tg) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_tag = tg;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * component getter / setter\n         * \n         * @param cmp (object) mofron.Component\n         * @return (object) mofron.Component\n         */\n\n    }, {\n        key: 'component',\n        value: function component(cmp) {\n            try {\n                if (undefined === cmp) {\n                    /* getter */\n                    return undefined === this.m_comp ? null : this.m_comp;\n                }\n                /* setter */\n                if (false === mofron.func.isInclude(cmp, 'Component')) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_comp = cmp;\n\n                /* set component attribute */\n                if (true === mofron.debug) {\n                    var nm = cmp.name().toLowerCase();\n                    if ('Component' !== nm) {\n                        cmp.adom().attr({ 'component': 'mofron-comp-' + nm });\n                    }\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'child',\n        value: function child(chd) {\n            try {\n                if (undefined === chd) {\n                    /* getter */\n                    return this.m_child;\n                }\n                /* setter */\n                if ('object' !== (typeof chd === 'undefined' ? 'undefined' : _typeof(chd))) {\n                    throw new Error('invalid parameter');\n                }\n\n                if (undefined !== chd[0]) {\n                    for (var idx in chd) {\n                        this.addChild(chd[idx]);\n                    }\n                    return;\n                }\n                this.addChild(chd);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * add child adom\n         *\n         * @param chd : (object) child adom\n         */\n\n    }, {\n        key: 'addChild',\n        value: function addChild(chd, idx) {\n            try {\n                if (false === mofron.func.isInclude(chd, 'Dom')) {\n                    throw new Error('invalid parameter');\n                }\n                chd.parent(this);\n\n                if (undefined === idx || 0 === this.m_child.length) {\n                    this.m_child.push(chd);\n                } else {\n                    this.m_child.splice(idx, 0, chd);\n                }\n                this.value(null);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'updChild',\n        value: function updChild(chd, idx) {\n            try {\n                if ('number' !== typeof idx || undefined === this.child()[idx]) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_child[idx].destroy();\n                this.addChild(chd, idx);\n                if (true === mofron.func.isObject(this, 'Adom') && 1 === this.child().length) {\n                    this.component().target(chd);\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'delChild',\n        value: function delChild(idx) {\n            try {\n                if ('number' !== typeof idx || undefined === this.child()[idx]) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_child.splice(idx, 1);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'styleListener',\n        value: function styleListener(key, func, prm) {\n            try {\n                if (undefined === key) {\n                    /* getter */\n                    return undefined === this.m_style_lis ? [] : this.m_style_lis;\n                }\n                /* setter */\n                if (undefined === this.m_style_lis) {\n                    this.m_style_lis = {};\n                }\n                if ('string' !== typeof key || 'function' !== typeof func) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_style_lis[key] = [func, prm];\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * style setter / getter\n         *\n         * @param kv : (object) key-value object\n         * @return (string) : value of style\n         * @return (object) : style object\n         */\n\n    }, {\n        key: 'style',\n        value: function style(kv, los) {\n            try {\n                if (undefined === kv || 'string' === typeof kv) {\n                    /* getter */\n                    return this.m_style.get(kv);\n                }\n                /* setter */\n                if (true === los) {\n                    this.m_style.protect(true);\n                    this.m_style.set(kv);\n                    this.m_style.protect(false);\n                } else if ('object' === (typeof kv === 'undefined' ? 'undefined' : _typeof(kv))) {\n                    this.m_style.set(kv);\n                }\n\n                /* execute style listener */\n                var lisner = this.styleListener();\n                for (var kv_idx in kv) {\n                    for (var lis_idx in lisner) {\n                        if (kv_idx === lis_idx) {\n                            lisner[lis_idx][0](lisner[lis_idx][1]);\n                        }\n                    }\n                }\n\n                this.value(null);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * tag attribute setter / getter\n         *\n         * @param kv  : (object/string) key-value object / key of attribute\n         * @param val : (object) value of attribute\n         * @return\n         */\n\n    }, {\n        key: 'attr',\n        value: function attr(kv, val) {\n            try {\n                if (undefined === val && 'object' !== (typeof kv === 'undefined' ? 'undefined' : _typeof(kv))) {\n                    /* getter */\n                    return this.m_attr.get(kv);\n                }\n                /* setter */\n                var chgcnf = {};\n                for (var kv_idx in kv) {\n                    if (kv[kv_idx] !== this.attr(kv_idx)) {\n                        chgcnf[kv_idx] = kv[kv_idx];\n                    }\n                }\n\n                if ('string' === typeof kv) {\n                    var set_obj = {};\n                    set_obj[kv] = val;\n                    this.m_attr.set(set_obj);\n                } else {\n                    this.m_attr.set(kv);\n                }\n\n                //if (0 !== chgcnf.length) {\n                //    this.execConfListener ('attr', chgcnf);\n                //}\n                this.value(null);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * dom property setter / getter\n         * \n         * @param kv  : (object/string) key-value object / key of\n         * @param val : (object)  value of property\n         */\n\n    }, {\n        key: 'prop',\n        value: function prop(kv, val) {\n            try {\n                if (undefined === val && 'object' !== (typeof kv === 'undefined' ? 'undefined' : _typeof(kv))) {\n                    /* getter */\n                    return this.m_prop.get(kv);\n                }\n                /* setter */\n                var chgcnf = {};\n                for (var kv_idx in kv) {\n                    if (kv[kv_idx] !== this.prop(kv_idx)) {\n                        chgcnf[kv_idx] = kv[kv_idx];\n                    }\n                }\n\n                if ('string' === typeof kv) {\n                    var set_obj = {};\n                    set_obj[kv] = val;\n                    this.m_prop.set(set_obj);\n                } else {\n                    this.m_prop.set(kv);\n                }\n\n                //if (0 !== chgcnf.length) {\n                //    this.execConfListener ('prop', chgcnf);\n                //}\n                this.value(null);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * tag class name setter / getter\n         * \n         * @param name : (string) class name\n         */\n\n    }, {\n        key: 'className',\n        value: function className(name) {\n            try {\n                if (undefined === name) {\n                    /* getter */\n                    return this.m_classnm.get();\n                }\n                /* setter */\n                this.m_classnm.add(name);\n                //this.execConfListener('className', name);\n                this.value(null);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * tag contents text setter / getter\n         * \n         * @param cnt : (string) tag contents (option)\n         * @return (string) tag contents\n         */\n\n    }, {\n        key: 'text',\n        value: function text(txt) {\n            try {\n                if (undefined === txt) {\n                    /* getter */\n                    return undefined === this.m_text ? '' : this.m_text;\n                }\n                /* setter */\n                if ('string' !== typeof txt) {\n                    throw new Error('invalid parameter');\n                }\n\n                var chgcnf = null;\n                if (txt !== this.text()) {\n                    chgcnf = txt;\n                }\n                this.m_text = txt;\n                if (true === this.isPushed()) {\n                    this.getRawDom().innerHTML = txt;\n                }\n\n                //if (null !== chgcnf) {\n                //this.execConfListener ('text', txt);\n                //}\n                this.value(null);\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        //addConfListener (fnc, prm) {\n        //    try {\n        //        if ('function' !== typeof fnc) {\n        //            throw new Error('invalid parameter');\n        //        }\n        //        this.m_cnflis.push([fnc, prm]);\n        //    } catch (e) {\n        //        console.error(e.stack);\n        //        throw e;\n        //    }\n        //}\n        //\n        //execConfListener (type, prm) {\n        //    try {\n        //        for (var idx in this.m_cnflis) {\n        //            this.m_cnflis[idx][0](\n        //                type,\n        //                prm,\n        //                this.m_cnflis[idx][1]\n        //            );\n        //        }\n        //    } catch (e) {\n        //        console.error(e.stack);\n        //        throw e;\n        //    }\n        //}\n\n        /**\n         * dom string setter / getter\n         *\n         * @return (string) dom string\n         */\n\n    }, {\n        key: 'value',\n        value: function value(val) {\n            try {\n                if (undefined === val) {\n                    /* getter */\n                    if (undefined !== this.m_value && 'string' === typeof this.m_value) {\n                        return this.m_value;\n                    }\n\n                    var ret_val = '';\n                    ret_val += '<' + this.tag() + ' ';\n\n                    /* set id attribute */\n                    ret_val += 'id=\"' + this.getId() + '\" ';\n\n                    /* set dom config */\n                    var cnf_lst = [this.m_classnm, this.m_style, this.m_attr];\n                    var cnf_cnt = null;\n                    for (var idx in cnf_lst) {\n                        cnf_cnt = cnf_lst[idx].getString();\n                        if ('' !== cnf_cnt) {\n                            ret_val += cnf_cnt;\n                        }\n                    }\n\n                    /* close tag */\n                    ret_val += '>';\n\n                    /* set tag contents */\n                    ret_val += this.text();\n\n                    /* set child value */\n                    var child = this.child();\n                    for (var chd_idx in child) {\n                        ret_val += child[chd_idx].value();\n                    }\n\n                    if (false === this.isSimple()) {\n                        ret_val += '</' + this.tag() + '>';\n                    }\n\n                    /* set buff */\n                    this.value(ret_val);\n\n                    return ret_val;\n                }\n                /* setter */\n                if (null === val && null !== this.parent()) {\n                    this.parent().value(null);\n                } else if (null !== val && 'string' !== typeof val) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_value = val;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * draw dom to target dom\n         * \n         * @param tgt : (object) target dom\n         * @param upd : (boolean) update flag\n         */\n\n    }, {\n        key: 'pushDom',\n        value: function pushDom(tgt, upd) {\n            try {\n                var _upd = undefined === upd ? false : upd;\n                if ('boolean' !== typeof _upd) {\n                    throw new Error('invalid parameter');\n                }\n\n                if (false === _upd && true === this.isPushed()) {\n                    throw new Error('already pushed');\n                }\n\n                this.parent(tgt);\n\n                if (true === mofron.ssr) {\n                    return;\n                }\n\n                var tgt_dom = null === this.parent() ? document.body : this.parent().getRawDom();\n                if (false === _upd) {\n                    tgt_dom.insertAdjacentHTML('beforeend', this.value());\n                } else {\n                    tgt_dom.innerHTML = this.value();\n                }\n                this.setPushed();\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * get adom status\n         *\n         * @return (boolean) true : this adom had pushed\n         * @return (boolean) false : this adom had not pushed\n         */\n\n    }, {\n        key: 'isPushed',\n        value: function isPushed() {\n            try {\n                return null === this.m_rawdom ? false : true;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * update adom status\n         * \n         * @note update status also child adom\n         */\n\n    }, {\n        key: 'setPushed',\n        value: function setPushed() {\n            try {\n                /* set rawdom */\n                var tgt_pnt = this.parent();\n                while (tgt_pnt) {\n                    if (true === tgt_pnt.isSimple()) {\n                        tgt_pnt = tgt_pnt.parent();\n                    } else {\n                        break;\n                    }\n                }\n                if (null === tgt_pnt) {\n                    this.m_rawdom = document.querySelector('#' + this.getId());\n                } else {\n                    this.m_rawdom = tgt_pnt.getRawDom().querySelector('#' + this.getId());\n                }\n\n                if (null === this.m_rawdom) {\n                    throw new Error('could not find rawdom');\n                }\n\n                /* set property */\n                var prop = this.m_prop.get();\n                for (var idx in prop) {\n                    this.prop(idx, prop[idx]);\n                }\n\n                if (0 != this.m_child.length) {\n                    for (var chd_idx in this.m_child) {\n                        this.m_child[chd_idx].setPushed();\n                    }\n                }\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * check whether tag name is simple tag\n         *\n         * @return (boolean) true  : this adom is simple tag\n         * @return (boolean) false : this adom is not simple tag\n         */\n\n    }, {\n        key: 'isSimple',\n        value: function isSimple(flg) {\n            try {\n                if (undefined === flg) {\n                    /* getter */\n                    if (undefined === this.m_simple) {\n                        return 'br' == this.tag() || 'hr' == this.tag() || 'input' == this.tag() || 'img' == this.tag() ? true : false;\n                    } else {\n                        return this.m_simple;\n                    }\n                }\n                /* setter */\n                if ('boolean' !== typeof flg) {\n                    throw new Error('invalid parameter');\n                }\n                this.m_simple = flg;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * parent adom setter / getter\n         * \n         * @param pnt : (object) parent dom/adom object\n         * @return (object) parant dom/adom object\n         */\n\n    }, {\n        key: 'parent',\n        value: function parent(pnt) {\n            try {\n                if (undefined === pnt) {\n                    /* getter */\n                    return undefined === this.m_parent ? null : this.m_parent;\n                }\n                /* setter */\n                if (null !== pnt && false === mofron.func.isInclude(pnt, 'Dom')) {\n                    throw new Error('invalid parameter');\n                }\n                if (undefined !== this.m_parent) {\n                    this.destroy();\n                }\n                this.m_parent = pnt;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n\n        /**\n         * get pushed dom object from blowser\n         *\n         * @return (object) raw dom object\n         */\n\n    }, {\n        key: 'getRawDom',\n        value: function getRawDom() {\n            try {\n                if (false === this.isPushed()) {\n                    throw new Error('this dom is not pushed yet');\n                }\n                return this.m_rawdom;\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            try {\n                if (true === this.isPushed() && true === mofron.func.isObject(this, 'Dom')) {\n                    this.getRawDom().remove();\n                    this.m_rawdom = null;\n                }\n                //let chd = this.child();\n                //for (let cidx in chd) {\n                //    chd[cidx].destroy();\n                //}\n                //if ( (null !== this.parent()) &&\n                //     (true === mofron.func.isInclude(this.parent(), 'Dom')) ) {\n                //    var pnt_chd = this.parent().child();\n                //    for (var idx in pnt_chd) {\n                //        if (pnt_chd[idx].getId() === this.getId()) {\n                //            this.parent().delChild(parseInt(idx));\n                //            break;\n                //        }\n                //    }\n                //}\n            } catch (e) {\n                console.error(e.stack);\n                throw e;\n            }\n        }\n    }]);\n\n    return _class;\n}(mofron.Base);\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/dom/Dom.js?")},"./src/js/conf/theme.js":function(module,exports,__webpack_require__){"use strict";eval('\n\n/**\n * @file theme.js\n * @brief app theme\n */\nvar mf = __webpack_require__(/*! mofron */ "./node_modules/mofron/index.js");\n\nmodule.exports = {\n    theme: function theme(thm) {\n        try {\n            // please define app theme here\n        } catch (e) {\n            console.error(e.stack);\n            throw e;\n        }\n    }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./src/js/conf/theme.js?')},"./src/js/init/index.js":function(module,exports,__webpack_require__){"use strict";eval('\n\n/**\n * @file index.js\n * @brief index page initialize\n */\nvar mf = __webpack_require__(/*! mofron */ "./node_modules/mofron/index.js");\n/* app ctrl */\nvar theme = __webpack_require__(/*! ../conf/theme.js */ "./src/js/conf/theme.js");\n\n/**\n * page init function\n * \n * @param rc (mf.Component) root component\n */\nvar start = function start(rc) {\n    try {\n        // page init here\n\n    } catch (e) {\n        console.error(e.stack);\n        throw e;\n    }\n};\n\ntry {\n    __webpack_require__(/*! expose-loader?app!../conf/namesp.js */ "./node_modules/expose-loader/index.js?app!./src/js/conf/namesp.js-exposed");\n    theme.theme(app.root.theme());\n    start(app.root);\n    app.root.visible(true);\n} catch (e) {\n    console.error(e.stack);\n}\n/* end of file */\n\n//# sourceURL=webpack:///./src/js/init/index.js?')}});